// ------------------------------------------------------------
// Mopo GPS -nopeusmittari T-Display S3: nopeus + heading + akku + trippi + Wi‚ÄëFi AP
// Lauta: LilyGO T-Display S3 (ESP32-S3 + ST7789)
// IDE: Arduino
// Kirjastot: TinyGPSPlus, TFT_eSPI, Preferences (sis√§ltyy), WiFi, WebServer
// ------------------------------------------------------------
// Ominaisuudet:
//  - Iso km/h nopeus, v√§ri vaihtuu punaiseksi > 45 km/h
//  - Oikealla nuoli + kurssi asteina (000‚Äì359)
//  - Akun j√§nnite (V) ja %
//  - GPS-satelliittien m√§√§r√§ (n√§yt√∂ll√§ ja webiss√§)
//  - GPS-fix (2D/3D) ja HDOP (n√§yt√∂ll√§ ja webiss√§)
//  - Kokonaismatka (ODO) ja trippi (TRIP), tallennus pysyv√§sti
//  - Wi‚ÄëFi AP + sis√§√§nrakennettu web-sivu: n√§ytt√§√§ ODO/TRIP ja napit TRIP reset & √∂ljynvaihdon nollaus
//  - √ñljynvaihtomuistutus 300 km v√§lein (n√§yt√∂lle varoitus), nollaus webist√§
//  - Web-sivulla huolto-ohjeen linkki (PDF) + footer "All code generated by ChatGPT 5"
// ------------------------------------------------------------

#include <Arduino.h>
#include <TinyGPSPlus.h>
#include <TFT_eSPI.h>
#include <SPI.h>
#include <WiFi.h>
#include <FS.h>          // <<< lis√§√§: jotta WebServer.h n√§kee FS-tyypin, jos FS_NO_GLOBALS on k√§yt√∂ss√§
using fs::FS;            // <<< globaali alias 'FS' -> 'fs::FS' (korjaa esp32 core 3.x WebServer-ETag-tyypin)
#include <WebServer.h>
#include <Preferences.h>
#include <math.h>

// ===================== K√§ytt√§j√§n muokattavat asetukset =====================
// GPS UART -pinnit (viestiss√§si: ESP32-S3 GPIO16 (RX), GPIO21 (TX))
static const int GPS_RX_PIN = 16;   // kytke GPS TX t√§h√§n
static const int GPS_TX_PIN = 21;   // kytke GPS RX t√§h√§n (usein vapaaehtoinen)
static const uint32_t GPS_BAUD = 9600;

// N√§ytt√∂asetuksia
static const uint32_t SPLASH_MS = 3000;   // aloitusn√§ytt√∂ n√§kyy n√§in pitk√§√§n (ms)
static const uint32_t UI_GPS_MS = 1000;    // ms, GPS-pohjaiset: nopeus/heading/fix/hdop
static const uint32_t UI_TOP_MS = 1000;    // ms, yl√§palkki (akku/SAT/√∂ljy)
static const float SPEED_RED_KMPH = 45.0f;   // punaisen raja

// Nopeuden suodatus (0..1), suurempi = reagoivampi
static const float SPEED_FILTER_ALPHA = 0.25f;

// Akun mittaus
// T-Display S3:lla akku on tyypillisesti luettavissa ADC:lt√§ GPIO4:n kautta (2:1 jakaja)
// Jos laudassasi eri pinni tai jako, muuta n√§m√§:
static const int   BAT_ADC_PIN       = 4;    // vaihtuu versiosta riippuen
static const float ADC_REF_VOLT      = 3.30f; // oletus
static const int   ADC_RES_BITS      = 12;    // 12-bit -> 4095
static const float BAT_DIVIDER_RATIO = 2.00f; // 2:1 jakaja -> kerro 2
static const float VBAT_CAL          = 1.00f; // kalibrointikerroin (s√§√§d√§ tarvittaessa)

// Odometrin suodatus/j√§rjestelyt
static const float DIST_ADD_MAX_KM_PER_TICK = 0.20f; // yksitt√§isen p√§ivityksen maks. hyv√§ksytt√§v√§ hypp√§ys (200 m)
static const float SPEED_MIN_ADD_KMPH       = 1.0f;  // alle t√§m√§n ei lis√§t√§ matkaa (v√§rin√§ / drift)

// √ñljynvaihdon v√§li (km)
static const float OIL_INTERVAL_KM = 300.0f; // muutettu 6000 -> 300 km

// Wi‚ÄëFi AP
static const char* AP_SSID = "MopoSpeedo";      // SSID
static const char* AP_PASS = "mopo12345";       // v√§h. 8 merkki√§ jos WPA2

// NMEA debug -silta USB:n yli (Serial <-> GPS). Oletus pois p√§√§lt√§.
static bool NMEA_BRIDGE = false;

// Huolto-ohjeen URL (PDF)
static const char* MAINT_URL = "https://www.hondabikes.fi/content/download/9264/61581/file/Z50J%20MONKEY%201992-99.pdf";

// NVS-nimet
static const char* PREF_NAMESPACE = "mopo";
static const char* KEY_ODO        = "total_km";
static const char* KEY_TRIP       = "trip_km";
static const char* KEY_OILBASE    = "oil_base";

// ===================== Globaalit =====================
static const int TFT_POWER_PIN = 15;   // LCD power enable when on battery (must be HIGH)
static const int TFT_BL_PIN    = 38;   // LCD backlight pin (PWM-capable)


TFT_eSPI tft;
TinyGPSPlus gps;
HardwareSerial GPSSerial(1);
WebServer server(80);
Preferences prefs;

uint32_t lastUiGpsMs = 0;
uint32_t lastUiTopMs = 0;
uint32_t lastGpsMs  = 0;

float filteredSpeed = 0.0f;   // km/h
float total_km = 0.0f;        // ODO
float trip_km  = 0.0f;        // TRIP
float oil_base_km = 0.0f;     // ODO arvo, jolloin √∂ljynvaihto nollattu

// GPS-viimeisin sijainti matkan laskentaan
bool   haveLastPos = false;
double lastLat = 0.0, lastLng = 0.0;

// Tallennuksen throttlaus
uint32_t lastSaveMs = 0;
float lastSavedTotal = -1.0f;
float lastSavedTrip  = -1.0f;
float lastSavedBase  = -1.0f;

// Oikean reunan paneelin leveys (nuoli + heading + huomiot)
static const int RIGHT_PANE_W = 120; // hieman leve√§mpi oikea paneeli vaakasuunnassa

// ===================== Apufunktiot: Akun prosentti =====================
static float lipoPercentFromVoltage(float v) {
  // Yksikennoinen LiPo (nopea, karkea malli). Clamppi 0..100
  // Referenssitaulukko (noin): 3.20V=0%, 3.50V=10%, 3.70V=50%, 3.85V=75%, 4.00V=90%, 4.20V=100%
  if (v <= 3.20f) return 0.0f;
  if (v >= 4.20f) return 100.0f;
  struct Pt { float v, p; } pts[] = {
    {3.20f,  0.0f},
    {3.50f, 10.0f},
    {3.70f, 50.0f},
    {3.85f, 75.0f},
    {4.00f, 90.0f},
    {4.20f,100.0f}
  };
  for (int i=0; i<5; ++i) {
    if (v >= pts[i].v && v <= pts[i+1].v) {
      float t = (v - pts[i].v) / (pts[i+1].v - pts[i].v);
      return pts[i].p + t * (pts[i+1].p - pts[i].p);
    }
  }
  return 0.0f;
}

static float readBatteryVoltage() {
  // Lue useampi n√§yte ja keskiarvoista
  const int N = 8;
  uint32_t sum = 0;
  for (int i=0; i<N; ++i) {
    sum += analogRead(BAT_ADC_PIN);
    delayMicroseconds(200);
  }
  float raw = sum / (float)N;
  float v = (raw / ((1<<ADC_RES_BITS) - 1)) * ADC_REF_VOLT * BAT_DIVIDER_RATIO * VBAT_CAL;
  return v; // Volttia
}

// ===================== Apufunktiot: Piirto =====================
static void drawHeadingArrow(float deg) {
  // Piirret√§√§n kolmio oikealle paneeliin, yl√§osaan
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;
  int h  = tft.height();
  int cx = x0 + w/2;
  int cy = 60;          // nuolen keskipiste Y
  int r1 = 6;           // nuolen "pohjan" s√§de
  int r2 = 26;          // nuolen k√§rjen s√§de

  // V√§lt√§ turhat p√§ivitykset
  static int lastDeg = -1000; // int-asteet
  int ideg = isnan(deg) ? -1 : (int)roundf(deg);
  if (ideg == lastDeg) return;
  lastDeg = ideg;

  // Tyhjenn√§ nuolialue
  tft.startWrite();
  tft.fillRect(x0, 0, w, 120, TFT_BLACK);

  if (isnan(deg)) {
    tft.setTextDatum(MC_DATUM);
    tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
    tft.setTextSize(2);
    tft.drawString("--", cx, cy);
    tft.endWrite();
    return;
  }

  // Muunna radiaaneiksi ja k√§√§nn√§ niin ett√§ 0¬∞ = yl√∂s
  float rad = (deg - 90.0f) * PI / 180.0f;

  auto px = [&](float r, float a){ return (int)roundf(cx + r * cosf(a)); };
  auto py = [&](float r, float a){ return (int)roundf(cy + r * sinf(a)); };

  int xTip = px(r2, rad);
  int yTip = py(r2, rad);
  int xL   = px(r1, rad + 2.5f);
  int yL   = py(r1, rad + 2.5f);
  int xR   = px(r1, rad - 2.5f);
  int yR   = py(r1, rad - 2.5f);

  tft.fillTriangle(xTip, yTip, xL, yL, xR, yR, TFT_WHITE);
  tft.endWrite();
}

static void drawHeadingText(int heading) {
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;

  static int lastHeading = -999;
  if (heading == lastHeading) return;
  lastHeading = heading;

  // Alue nuolen alle
  tft.startWrite();
  tft.fillRect(x0, 120, w, 40, TFT_BLACK);
  tft.setTextDatum(MC_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  char buf[8];
  if (heading < 0) snprintf(buf, sizeof(buf), "---");
  else snprintf(buf, sizeof(buf), "%03d", heading % 360);
  tft.drawString(buf, x0 + w/2, 138);
  tft.endWrite();
}

static void drawFixInfo(int fix, float hdop) {
  // Piirr√§ oikeaan paneeliin fix-tila ja HDOP nuolen/headingin alle
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;
  int y  = tft.height() - 12; // sijoittelu aivan alaosaan, aina n√§kyviss√§

  static int lastFix = -1;
  static int lastHdT = -10000; // hdop*10 py√∂ristettyn√§
  int hdT = isnan(hdop) ? -1 : (int)roundf(hdop*10.0f);
  if (fix == lastFix && hdT == lastHdT) return;
  lastFix = fix; lastHdT = hdT;

  tft.startWrite();
  tft.fillRect(x0, tft.height()-40, w, 40, TFT_BLACK);

  const char* fx = (fix == 3 ? "3D" : (fix == 2 ? "2D" : "--"));
  char buf[24];
  if (!isnan(hdop)) snprintf(buf, sizeof(buf), "FX:%s H:%.1f", fx, hdop);
  else snprintf(buf, sizeof(buf), "FX:%s H:--", fx);

  tft.setTextDatum(MC_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString(buf, x0 + w/2, y);
  tft.endWrite();
}

static void drawTopBar(float vbat, float pbat, int sats, bool oilDue) {
  // Yl√§palkki: akku + SAT + √∂ljyikoni
  int x0 = 0, y0 = 0;
  int w = tft.width() - RIGHT_PANE_W; // vasen alue
  int h = 24;

  char buf[64];
  if (sats >= 0) snprintf(buf, sizeof(buf), "%.2fV  %d%%  S%02d", vbat, (int)roundf(pbat), sats);
  else snprintf(buf, sizeof(buf), "%.2fV  %d%%  S--", vbat, (int)roundf(pbat));

  // Piirr√§ vain jos sis√§lt√∂ muuttui
  static char last[64] = "";
  static bool lastOil = false;
  if (!strcmp(last, buf) && oilDue == lastOil) return;
  strcpy(last, buf); lastOil = oilDue;

  tft.startWrite();
  tft.fillRect(x0, y0, w, h, TFT_BLACK);
  tft.setTextDatum(ML_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString(buf, 6, y0 + h/2);
  if (oilDue) {
    tft.setTextDatum(MR_DATUM);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.drawString("‚õΩ Oljy!", x0 + w - 6, y0 + h/2);
  }
  tft.endWrite();
}



/* poistettu vaakan√§yt√∂ss√§: ODO/TRIP vain webiss√§ */

static int fontH(int s){ return 8*s; } // GLCD-perusfontti

static void drawSpeed(float kmph) {
  // Iso nopeus vasemmalle, 'km/h' pienen√§ per√§ss√§. P√§ivit√§ vain kun muuttuu.
  int w = tft.width() - RIGHT_PANE_W;
  int h = tft.height();
  int top = 24;        // j√§t√§ topbar
  int areaH = h - top; // ei alapalkkia

  // V√§ri rajan mukaan
  uint16_t col = (kmph > SPEED_RED_KMPH) ? TFT_RED : TFT_WHITE;

  // Nopeus kokonaislukuna
  int spd = (int)roundf(max(0.0f, kmph));

  static int lastSpd = -9999;
  static uint16_t lastCol = 0;
  if (spd == lastSpd && col == lastCol) return; // ei muutosta -> ei redraw
  lastSpd = spd; lastCol = col;

  char buf[16];
  snprintf(buf, sizeof(buf), "%d", spd);

  // Tavoite: mahdutetaan (numero + v√§li + "km/h") vasemmalle leveydelle
  int targetW = (int)(w * 0.95f);
  int centerY = top + areaH / 2;

  int bestMain = 1;
  int bestNumW = 0, bestSfxW = 0;
  for (int s = 10; s >= 1; --s) {
    tft.setTextSize(s);
    int numW = tft.textWidth(buf);
    int sfxS = max(1, s/2);  // pienempi "km/h"
    tft.setTextSize(sfxS);
    int sfxW = tft.textWidth("km/h");
    int total = numW + 8 + sfxW; // 8px v√§li
    if (total <= targetW) { bestMain = s; bestNumW = numW; bestSfxW = sfxW; break; }
  }

  // Tyhjenn√§ keskialue vain redrawin yhteydess√§
  tft.startWrite();
  tft.fillRect(0, top, w, areaH, TFT_BLACK);

  // Piirr√§ keskitettyn√§ vaakasuunnassa
  int totalW = bestNumW + 8 + bestSfxW;
  int startX = (w - totalW) / 2;

  // Numero
  tft.setTextDatum(ML_DATUM); // Middle-Left
  tft.setTextSize(bestMain);
  tft.setTextColor(col, TFT_BLACK);
  tft.drawString(buf, startX, centerY);

  // Suffix "km/h"
  tft.setTextSize(max(1, bestMain/2));
  tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
  tft.drawString("km/h", startX + bestNumW + 8, centerY);
  tft.endWrite();
}



// ===================== GPS apu =====================
static int satCount() {
  if (gps.satellites.isValid()) return (int)gps.satellites.value();
  return -1;
}

static int fixType() {
  // Heuristiikka: jos sijainti validi ja tuore -> v√§hint√§√§n 2D; jos my√∂s korkeus validi ja tuore -> 3D
  bool locOK = gps.location.isValid() && gps.location.age() < 2000;
  bool altOK = gps.altitude.isValid() && gps.altitude.age() < 2000;
  if (!locOK) return 0;         // No fix
  if (altOK) return 3;          // 3D
  return 2;                     // 2D
}

static float hdopValue() {
  if (gps.hdop.isValid()) {
    // TinyGPS++: hdop.value() on sadasosissa
    return gps.hdop.value() / 100.0f;
  }
  return NAN;
}

static int safeHeading() {
  if (gps.course.isValid() && gps.location.isValid()) {
    return (int)round(gps.course.deg());
  }
  return -1;
}

static void maybeAddDistance() {
  if (!gps.location.isValid()) return;
  if (!gps.location.isUpdated()) return;

  double lat = gps.location.lat();
  double lng = gps.location.lng();

  if (gps.speed.isValid()) {
    if (gps.speed.kmph() < SPEED_MIN_ADD_KMPH) {
      // liian hidas -> j√§t√§ lis√§√§m√§tt√§
      haveLastPos = false; // pakota uusi l√§ht√∂piste, ettei kerry pieni√§ virheit√§ paikallaan
      return;
    }
  }

  if (haveLastPos) {
    double d_m = TinyGPSPlus::distanceBetween(lastLat, lastLng, lat, lng); // metrein√§
    double d_km = d_m / 1000.0;
    if (d_km >= 0.0 && d_km <= DIST_ADD_MAX_KM_PER_TICK) {
      total_km += (float)d_km;
      trip_km  += (float)d_km;
    }
  }
  lastLat = lat;
  lastLng = lng;
  haveLastPos = true;
}

// ===================== Wi‚ÄëFi & Web =====================
static String urlEncode(const String &s) {
  String out; out.reserve(s.length()*3);
  const char *hex = "0123456789ABCDEF";
  for (size_t i=0; i<s.length(); ++i) {
    unsigned char c = (unsigned char)s[i];
    if ((c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9')||c=='-'||c=='_'||c=='.'||c=='~') out += (char)c;
    else { out += '%'; out += hex[(c>>4)&0xF]; out += hex[c&0xF]; }
  }
  return out;
}

static String htmlPage() {
  // Luo yksinkertainen status-sivu
  float vbat = readBatteryVoltage();
  int   pbat = (int)roundf(lipoPercentFromVoltage(vbat));
  bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
  float kmToOil = max(0.0f, OIL_INTERVAL_KM - (total_km - oil_base_km));
  int sats = satCount();
  int fix = fixType();
  float hd = hdopValue();

  String s;
  s += F("<!doctype html><html><head><meta charset=\"utf-8\"><meta name=viewport content=\"width=device-width,initial-scale=1\">\n");
  s += F("<title>MopoSpeedo</title><style>body{font-family:sans-serif;margin:20px} .k{font-size:22px} button{font-size:18px;padding:8px 14px;margin:6px}</style></head><body>");
  s += F("<h2>MopoSpeedo</h2>");
  s += F("<p style=\"font-size:14px;color:#777\">NMEA debug: "); s += (NMEA_BRIDGE?"<b>P√§√§ll√§</b>":"Pois"); s += F(" ‚Äî ");
  if (!NMEA_BRIDGE) s += F("<a href=\"/nmea_on\">Kytke p√§√§lle</a>"); else s += F("<a href=\"/nmea_off\">Kytke pois</a>");
  s += F("</p>");
  s += F("<div class=k><b>Kokonaismatka (ODO): </b>"); s += String(total_km, 1); s += F(" km</div>");
  s += F("<div class=k><b>Trippimittari (TRIP): </b>"); s += String(trip_km, 1); s += F(" km</div>");
  s += F("<div class=k><b>Satelliitit:</b> "); s += (sats>=0? String(sats): String("--")); s += F(" kpl</div>");
  s += F("<div class=k><b>GPS-fix:</b> "); s += (fix==3?"3D":(fix==2?"2D":"--")); s += F("</div>");
  s += F("<div class=k><b>HDOP:</b> "); s += (!isnan(hd)? String(hd,1): String("--")); s += F("</div>");
  s += F("<div class=k><b>Akku: </b>"); s += String(vbat, 2); s += F(" V &nbsp;("); s += String(pbat); s += F("%)</div>");
  s += F("<hr>");
  if (oilDue) {
    s += F("<div class=k style=\"color:#c00\"><b>\u26FD √ñljynvaihtohuomio:</b> Suositus teht√§v√§ nyt!</div>");
  } else {
    s += F("<div class=k><b>√ñljynvaihtoon:</b> "); s += String(kmToOil, 0); s += F(" km</div>");
  }
  s += F("<p><form action='/reset_trip' method='post'><button>‚ú≥ Nollaa TRIP</button></form></p>");
  s += F("<p><form action='/reset_oil' method='post'><button>üõ¢ Nollaa √∂ljynvaihto</button></form></p>");
  s += F("<p style=\"color:#666\">P√§√§sy: Wi‚ÄëFi AP \"MopoSpeedo\" (salasana \"mopo12345\"); Osoite: <a href='http://192.168.4.1/'>192.168.4.1</a></p>");
  s += F("<hr><h3>Huolto-ohje</h3>");
  s += F("<p><a href=\""); s += String(MAINT_URL); s += F("\" target=\"_blank\">Honda Monkey Z50J 1992‚Äì99 huolto-ohje (PDF)</a></p>");
  s += F("<hr><p style=\"color:#777;font-size:13px\">All code generated by ChatGPT 5</p></body></html>");
  return s;
}

static void handleRoot() { server.send(200, "text/html; charset=utf-8", htmlPage()); }
static void handleData() {
  float vbat = readBatteryVoltage();
  int pbat = (int)roundf(lipoPercentFromVoltage(vbat));
  bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
  int sats = satCount();
  int fix = fixType();
  float hd = hdopValue();
  String j = "{";
  j += "\"odo_km\":" + String(total_km, 3) + ",";
  j += "\"trip_km\":" + String(trip_km, 3) + ",";
  j += "\"vbat\":" + String(vbat, 3) + ",";
  j += "\"pbat\":" + String(pbat) + ",";
  j += "\"sats\":" + String(sats) + ",";
  j += "\"fix\":\"" + String(fix==3?"3D":(fix==2?"2D":"NONE")) + "\",";
  if (!isnan(hd)) j += "\"hdop\":" + String(hd, 2) + ","; else j += "\"hdop\":null,";
  j += "\"oil_due\":" + String(oilDue ? "true" : "false") + ",";
  j += "\"oil_next_km\":" + String(max(0.0f, OIL_INTERVAL_KM - (total_km - oil_base_km)), 1);
  j += "}";
  server.send(200, "application/json", j);
}


static void handleResetTrip() {
  trip_km = 0.0f;
  server.sendHeader("Location", "/");
  server.send(303);
}
static void handleResetOil() {
  oil_base_km = total_km;
  server.sendHeader("Location", "/");
  server.send(303);
}

static void setupWiFiAP() {
  WiFi.persistent(false);
  WiFi.mode(WIFI_AP);
  WiFi.setSleep(false);
  WiFi.softAP(AP_SSID, AP_PASS);
  delay(200);
  IPAddress ip = WiFi.softAPIP();
  Serial.print("AP IP: "); Serial.println(ip);

  server.on("/", HTTP_GET, handleRoot);
  server.on("/data.json", HTTP_GET, handleData);
  server.on("/reset_trip", HTTP_POST, handleResetTrip);
  server.on("/reset_oil",  HTTP_POST, handleResetOil);
  server.on("/manual", HTTP_GET, [](){ server.sendHeader("Location", MAINT_URL); server.send(302); });
  server.on("/nmea_on",  HTTP_GET, [](){ NMEA_BRIDGE = true;  server.sendHeader("Location","/"); server.send(303); });
  server.on("/nmea_off", HTTP_GET, [](){ NMEA_BRIDGE = false; server.sendHeader("Location","/"); server.send(303); });
  server.begin();
}

// ===================== Tallennus =====================
static void maybeSavePrefs() {
  uint32_t now = millis();
  if (now - lastSaveMs < 5000) return; // 5 s v√§li
  lastSaveMs = now;

  bool changed = false;
  if (fabs(total_km - lastSavedTotal) > 0.01f) { prefs.putFloat(KEY_ODO, total_km); lastSavedTotal = total_km; changed = true; }
  if (fabs(trip_km  - lastSavedTrip ) > 0.01f) { prefs.putFloat(KEY_TRIP, trip_km);   lastSavedTrip  = trip_km;  changed = true; }
  if (fabs(oil_base_km - lastSavedBase) > 0.01f) { prefs.putFloat(KEY_OILBASE, oil_base_km); lastSavedBase = oil_base_km; changed = true; }
  if (changed) Serial.println(F("[NVS] Talletettu ODO/TRIP/OILBASE"));
}

// ===================== setup/loop =====================
void setup() {
  Serial.begin(115200);
  delay(50);

  // --- Kriittiset T-Display S3 virrat: kun lauta on AKULLA, n√§ytt√∂ pysyy pime√§n√§ ellei 15 -> HIGH ---
  pinMode(TFT_POWER_PIN, OUTPUT);
  digitalWrite(TFT_POWER_PIN, HIGH);   // kytke n√§yt√∂n virta p√§√§lle (FAQ)
  pinMode(TFT_BL_PIN, OUTPUT);
  digitalWrite(TFT_BL_PIN, HIGH);      // taustavalo p√§√§lle
  delay(50);

  // TFT
  tft.init();
  tft.setRotation(3); // vaaka-asento
  tft.fillScreen(TFT_BLACK);
  tft.setTextSize(1);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setTextDatum(MC_DATUM);

  // Splash-n√§ytt√∂ (Honda Monkey 1994)
  // Piirret√§√§n tyylitelty punainen "siipi" ja tekstit
  {
    int w = tft.width();
    int h = tft.height();
    int cx = w/2;
    int cy = h/2;

    // Siiven paikka vasemmalle puolelle
    int sx = cx - 70; // siiven vasen
    int sy = cy - 18; // siiven yl√§ankkuri

    // Piirr√§ 5 vinoa punaista "sulkakerrosta"
    tft.startWrite();
    for (int i=0;i<5;++i){
      int yy = sy + i*8;
      int barW = 64 - i*10; // kapenee alasp√§in
      int barH = 6;
      // Viistopalkki parallelogrammina kahdella kolmiolla
      // vasen alareuna -> oikea ylempi reuna (vinous)
      int x1 = sx;
      int y1 = yy;
      int x2 = sx + barW;
      int y2 = yy - 6; // kallistus yl√∂s oikealle
      int x3 = sx + barW;
      int y3 = yy + barH - 6;
      int x4 = sx;
      int y4 = yy + barH;
      tft.fillTriangle(x1,y1,x2,y2,x3,y3,TFT_RED);
      tft.fillTriangle(x1,y1,x4,y4,x3,y3,TFT_RED);
    }
    tft.endWrite();

    // Tekstit oikealle puolelle
    tft.setTextDatum(ML_DATUM);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextSize(3);
    tft.drawString("HONDA", cx - 10, cy - 6);
    tft.setTextSize(2);
    tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
    tft.drawString("Monkey 1994", cx - 10, cy + 14);

    // Credits rivi alareunaan
    tft.setTextDatum(MC_DATUM);
    tft.setTextSize(1);
    tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
    tft.drawString("All code generated by ChatGPT 5", w/2, h - 10);
  }

  delay(SPLASH_MS);

  // ADC
  analogReadResolution(ADC_RES_BITS);
  analogSetPinAttenuation(BAT_ADC_PIN, ADC_11db);

  // GPS UART
  GPSSerial.begin(GPS_BAUD, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);

  // NVS
  prefs.begin(PREF_NAMESPACE, false);
  total_km    = prefs.getFloat(KEY_ODO, 0.0f);
  trip_km     = prefs.getFloat(KEY_TRIP, 0.0f);
  oil_base_km = prefs.getFloat(KEY_OILBASE, total_km);
  lastSavedTotal = total_km;
  lastSavedTrip  = trip_km;
  lastSavedBase  = oil_base_km;

  // Wi‚ÄëFi AP + web
  setupWiFiAP();

  delay(100);
  tft.fillScreen(TFT_BLACK);
}

void loop() {
  // GPS sy√∂tt√∂
  while (GPSSerial.available() > 0) {
    char c = GPSSerial.read();
    if (gps.encode(c)) lastGpsMs = millis();
  }

  // P√§ivit√§ matka kun sijainti p√§ivittyy
  maybeAddDistance();

  // N√§yt√∂n p√§ivitys (throttlattu)
  uint32_t now = millis();

  // 1) GPS-pohjaiset elementit noin 1 Hz
  if (now - lastUiGpsMs >= UI_GPS_MS) {
    lastUiGpsMs = now;

    // Nopeus -> suodatus (TinyGPS++ p√§ivittyy tyypillisesti 1 Hz)
    if (gps.speed.isValid() && (now - lastGpsMs) < 2000) {
      float k = gps.speed.kmph();
      filteredSpeed = SPEED_FILTER_ALPHA * k + (1.0f - SPEED_FILTER_ALPHA) * filteredSpeed;
    } else {
      filteredSpeed = 0.95f * filteredSpeed; if (filteredSpeed < 0.05f) filteredSpeed = 0.0f;
    }

    drawSpeed(filteredSpeed);
    int hdg = safeHeading();
    drawHeadingArrow((float)hdg);
    drawHeadingText(hdg);
    drawFixInfo(fixType(), hdopValue());
  }

  // 2) Yl√§palkki noin 1 Hz, mutta piirret√§√§n vain kun sis√§lt√∂ muuttuu
  if (now - lastUiTopMs >= UI_TOP_MS) {
    lastUiTopMs = now;
    float vbat = readBatteryVoltage();
    float pbat = lipoPercentFromVoltage(vbat);
    int sats = satCount();
    bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
    drawTopBar(vbat, pbat, sats, oilDue);
  }

  // Web-palvelin
  server.handleClient();

  // NMEA debug -silta: kaikki GPS->USB ja USB->GPS l√§pi
  if (NMEA_BRIDGE) {
    while (GPSSerial.available()) {
      char c = GPSSerial.read();
      Serial.write(c);       // n√§yt√§ Serial Monitorissa kaikki NMEA/UBX
      gps.encode(c);         // pid√§ parseri silti hengiss√§
      lastGpsMs = millis();
    }
    while (Serial.available()) {
      char c = Serial.read();
      GPSSerial.write(c);    // mahdollista l√§hett√§√§ komentoja GPS:lle (esim. u-blox)
    }
  }

  // Talletus
  maybeSavePrefs();
}
