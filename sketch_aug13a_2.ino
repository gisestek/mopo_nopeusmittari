// -----------------------------------------------------------------------------
// Honda Monkey Speedometer (ESP32-S3 T-Display S3)
// UI: big km/h + right-side compass arrow & heading (000‚Äì359)
// Top bar: battery volts + %, satellites; oil-service reminder every 300 km
// Wi‚ÄëFi AP: status page shows ODO/TRIP, reset buttons, service link, debug
// Splash: "HONDA / Monkey 1994" + "All code generated by ChatGPT 5"
// -----------------------------------------------------------------------------
// SPEED CALCULATION (short version):
//  - We read speed from the GPS receiver via TinyGPS++: gps.speed.kmph()
//    (this is NMEA ground speed; update rate typically 1 Hz).
//  - We **gate** the speed with hasFixStrong(): only show/use speed when location
//    is valid & fresh (<2 s), satellites >= 3 and HDOP < 10. Otherwise the speed
//    text is grey and the internal filtered speed decays toward 0 to avoid drift.
//  - We apply **exponential smoothing** to avoid flicker: filtered = a*raw + (1-a)*prev
//    (SPEED_FILTER_ALPHA). We refresh the speed on screen only when the integer
//    km/h changes or the color changes (<= 1 Hz UI update), which eliminates flicker.
//  - Distance (ODO/TRIP) is integrated from GPS positions using TinyGPSPlus::
//    distanceBetween(last, now). We only add distance when the reported speed is
//    above SPEED_MIN_ADD_KMPH to avoid stationary noise, and we clamp single- tick
//    increments to DIST_ADD_MAX_KM_PER_TICK to reject outliers.
// -----------------------------------------------------------------------------
#include <Arduino.h>
#include <TinyGPSPlus.h>
#include <TFT_eSPI.h>
#include <SPI.h>
#include <WiFi.h>
#include <FS.h>          // <<< lis√§√§: jotta WebServer.h n√§kee FS-tyypin, jos FS_NO_GLOBALS on k√§yt√∂ss√§
using fs::FS;            // <<< globaali alias 'FS' -> 'fs::FS' (korjaa esp32 core 3.x WebServer-ETag-tyypin)
#include <WebServer.h>
#include <Preferences.h>
#include <math.h>

// ===================== K√§ytt√§j√§n muokattavat asetukset =====================
// GPS UART -pinnit (viestiss√§si: ESP32-S3 GPIO16 (RX), GPIO21 (TX))
static const int GPS_RX_PIN = 16;   // kytke GPS TX t√§h√§n
static const int GPS_TX_PIN = 21;   // kytke GPS RX t√§h√§n (usein vapaaehtoinen)
static const uint32_t GPS_BAUD = 9600;
static uint32_t GPS_BAUD_USED = GPS_BAUD; // p√§ivitet√§√§n automaattisesti
static bool GPS_DET_UBX = false;         // jos havaitaan UBX-binaari, merkit√§√§n t√§m√§

// N√§ytt√∂asetuksia
static const uint32_t SPLASH_MS = 3000;   // aloitusn√§ytt√∂ n√§kyy n√§in pitk√§√§n (ms)
static const uint32_t UI_GPS_MS = 1000;    // ms, GPS-pohjaiset: nopeus/heading/fix/hdop
static const uint32_t UI_TOP_MS = 1000;    // ms, yl√§palkki (akku/SAT/√∂ljy)
static const float SPEED_RED_KMPH = 45.0f;   // punaisen raja

// Exponential smoothing for speed (0..1). Higher = more responsive, lower = smoother
static const float SPEED_FILTER_ALPHA = 0.25f;

// Akun mittaus
// T-Display S3:lla akku on tyypillisesti luettavissa ADC:lt√§ GPIO4:n kautta (2:1 jakaja)
// Jos laudassasi eri pinni tai jako, muuta n√§m√§:
static const int   BAT_ADC_PIN       = 4;    // vaihtuu versiosta riippuen
static const float ADC_REF_VOLT      = 3.30f; // oletus
static const int   ADC_RES_BITS      = 12;    // 12-bit -> 4095
static const float BAT_DIVIDER_RATIO = 2.00f; // 2:1 jakaja -> kerro 2
static const float VBAT_CAL          = 1.00f; // kalibrointikerroin (s√§√§d√§ tarvittaessa)

// Odometrin suodatus/j√§rjestelyt
static const float DIST_ADD_MAX_KM_PER_TICK = 0.20f; // yksitt√§isen p√§ivityksen maks. hyv√§ksytt√§v√§ hypp√§ys (200 m)
static const float SPEED_MIN_ADD_KMPH       = 1.0f;  // alle t√§m√§n ei lis√§t√§ matkaa (v√§rin√§ / drift)

// √ñljynvaihdon v√§li (km)
static const float OIL_INTERVAL_KM = 300.0f; // muutettu 6000 -> 300 km

// Wi‚ÄëFi AP
static const char* AP_SSID = "MopoSpeedo";      // SSID
static const char* AP_PASS = "mopo12345";       // v√§h. 8 merkki√§ jos WPA2

// NMEA debug -silta USB:n yli (Serial <-> GPS). Oletus pois p√§√§lt√§.
static bool NMEA_BRIDGE = false;

// Huolto-ohjeen URL (PDF)
static const char* MAINT_URL = "https://www.hondabikes.fi/content/download/9264/61581/file/Z50J%20MONKEY%201992-99.pdf";

// NVS-nimet
static const char* PREF_NAMESPACE = "mopo";
static const char* KEY_ODO        = "total_km";
static const char* KEY_TRIP       = "trip_km";
static const char* KEY_OILBASE    = "oil_base";

// ===================== Globaalit =====================
static const int TFT_POWER_PIN = 15;   // LCD power enable when on battery (must be HIGH)
static const int TFT_BL_PIN    = 38;   // LCD backlight pin (PWM-capable)


TFT_eSPI tft;
TinyGPSPlus gps;
HardwareSerial GPSSerial(1);
WebServer server(80);
Preferences prefs;

uint32_t lastUiGpsMs = 0;
uint32_t lastUiTopMs = 0;
uint32_t lastGpsMs  = 0;

float filteredSpeed = 0.0f;   // km/h
float total_km = 0.0f;        // ODO
float trip_km  = 0.0f;        // TRIP
float oil_base_km = 0.0f;     // ODO arvo, jolloin √∂ljynvaihto nollattu

// GPS-viimeisin sijainti matkan laskentaan
bool   haveLastPos = false;
double lastLat = 0.0, lastLng = 0.0;

// Tallennuksen throttlaus
uint32_t lastSaveMs = 0;
float lastSavedTotal = -1.0f;
float lastSavedTrip  = -1.0f;
float lastSavedBase  = -1.0f;

// Oikean reunan paneelin leveys (nuoli + heading + huomiot)
static const int RIGHT_PANE_W = 120; // hieman leve√§mpi oikea paneeli vaakasuunnassa

// ===================== Apufunktiot: Akun prosentti =====================
static float lipoPercentFromVoltage(float v) {
  // Yksikennoinen LiPo (nopea, karkea malli). Clamppi 0..100
  // Referenssitaulukko (noin): 3.20V=0%, 3.50V=10%, 3.70V=50%, 3.85V=75%, 4.00V=90%, 4.20V=100%
  if (v <= 3.20f) return 0.0f;
  if (v >= 4.20f) return 100.0f;
  struct Pt { float v, p; } pts[] = {
    {3.20f,  0.0f},
    {3.50f, 10.0f},
    {3.70f, 50.0f},
    {3.85f, 75.0f},
    {4.00f, 90.0f},
    {4.20f,100.0f}
  };
  for (int i=0; i<5; ++i) {
    if (v >= pts[i].v && v <= pts[i+1].v) {
      float t = (v - pts[i].v) / (pts[i+1].v - pts[i].v);
      return pts[i].p + t * (pts[i+1].p - pts[i].p);
    }
  }
  return 0.0f;
}

static float readBatteryVoltage() {
  // Lue useampi n√§yte ja keskiarvoista
  const int N = 8;
  uint32_t sum = 0;
  for (int i=0; i<N; ++i) {
    sum += analogRead(BAT_ADC_PIN);
    delayMicroseconds(200);
  }
  float raw = sum / (float)N;
  float v = (raw / ((1<<ADC_RES_BITS) - 1)) * ADC_REF_VOLT * BAT_DIVIDER_RATIO * VBAT_CAL;
  return v; // Volttia
}

// ===================== Apufunktiot: Piirto =====================
static void drawHeadingArrow(float deg) {
  // Piirret√§√§n kolmio oikealle paneeliin, yl√§osaan
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;
  int h  = tft.height();
  int cx = x0 + w/2;
  int cy = 60;          // nuolen keskipiste Y
  int r1 = 6;           // nuolen "pohjan" s√§de
  int r2 = 26;          // nuolen k√§rjen s√§de

  // V√§lt√§ turhat p√§ivitykset
  static int lastDeg = -1000; // int-asteet
  int ideg = isnan(deg) ? -1 : (int)roundf(deg);
  if (ideg == lastDeg) return;
  lastDeg = ideg;

  // Tyhjenn√§ nuolialue
  tft.startWrite();
  tft.fillRect(x0, 0, w, 120, TFT_BLACK);

  if (isnan(deg)) {
    tft.setTextDatum(MC_DATUM);
    tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
    tft.setTextSize(2);
    tft.drawString("--", cx, cy);
    tft.endWrite();
    return;
  }

  // Muunna radiaaneiksi ja k√§√§nn√§ niin ett√§ 0¬∞ = yl√∂s
  float rad = (deg - 90.0f) * PI / 180.0f;

  auto px = [&](float r, float a){ return (int)roundf(cx + r * cosf(a)); };
  auto py = [&](float r, float a){ return (int)roundf(cy + r * sinf(a)); };

  int xTip = px(r2, rad);
  int yTip = py(r2, rad);
  int xL   = px(r1, rad + 2.5f);
  int yL   = py(r1, rad + 2.5f);
  int xR   = px(r1, rad - 2.5f);
  int yR   = py(r1, rad - 2.5f);

  tft.fillTriangle(xTip, yTip, xL, yL, xR, yR, TFT_WHITE);
  tft.endWrite();
}

static void drawHeadingText(int heading) {
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;

  static int lastHeading = -999;
  if (heading == lastHeading) return;
  lastHeading = heading;

  // Alue nuolen alle
  tft.startWrite();
  tft.fillRect(x0, 120, w, 40, TFT_BLACK);
  tft.setTextDatum(MC_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  char buf[8];
  if (heading < 0) snprintf(buf, sizeof(buf), "---");
  else snprintf(buf, sizeof(buf), "%03d", heading % 360);
  tft.drawString(buf, x0 + w/2, 138);
  tft.endWrite();
}

static void drawFixInfo(int fix, float hdop) {
  // Piirr√§ oikeaan paneeliin fix-tila ja HDOP nuolen/headingin alle
  int x0 = tft.width() - RIGHT_PANE_W;
  int w  = RIGHT_PANE_W;
  int y  = tft.height() - 12; // sijoittelu aivan alaosaan, aina n√§kyviss√§

  static int lastFix = -1;
  static int lastHdT = -10000; // hdop*10 py√∂ristettyn√§
  int hdT = isnan(hdop) ? -1 : (int)roundf(hdop*10.0f);
  if (fix == lastFix && hdT == lastHdT) return;
  lastFix = fix; lastHdT = hdT;

  tft.startWrite();
  tft.fillRect(x0, tft.height()-40, w, 40, TFT_BLACK);

  const char* fx = (fix == 3 ? "3D" : (fix == 2 ? "2D" : "--"));
  char buf[24];
  if (!isnan(hdop)) snprintf(buf, sizeof(buf), "FX:%s H:%.1f", fx, hdop);
  else snprintf(buf, sizeof(buf), "FX:%s H:--", fx);

  tft.setTextDatum(MC_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString(buf, x0 + w/2, y);
  tft.endWrite();
}

static void drawTopBar(float vbat, float pbat, int sats, bool oilDue) {
  // Yl√§palkki: akku + SAT + √∂ljyikoni
  int x0 = 0, y0 = 0;
  int w = tft.width() - RIGHT_PANE_W; // vasen alue
  int h = 24;

  char buf[64];
  if (sats >= 0) snprintf(buf, sizeof(buf), "%.2fV  %d%%  S%02d", vbat, (int)roundf(pbat), sats);
  else snprintf(buf, sizeof(buf), "%.2fV  %d%%  S--", vbat, (int)roundf(pbat));

  // Piirr√§ vain jos sis√§lt√∂ muuttui
  static char last[64] = "";
  static bool lastOil = false;
  if (!strcmp(last, buf) && oilDue == lastOil) return;
  strcpy(last, buf); lastOil = oilDue;

  tft.startWrite();
  tft.fillRect(x0, y0, w, h, TFT_BLACK);
  tft.setTextDatum(ML_DATUM);
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.drawString(buf, 6, y0 + h/2);
  if (oilDue) {
    tft.setTextDatum(MR_DATUM);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.drawString("‚õΩ Oljy!", x0 + w - 6, y0 + h/2);
  }
  tft.endWrite();
}



/* poistettu vaakan√§yt√∂ss√§: ODO/TRIP vain webiss√§ */

static int fontH(int s){ return 8*s; } // GLCD-perusfontti

static void drawSpeed(float kmph) {
  // Iso nopeus vasemmalle, 'km/h' pienen√§ per√§ss√§. P√§ivit√§ vain kun muuttuu.
  int w = tft.width() - RIGHT_PANE_W;
  int h = tft.height();
  int top = 24;        // j√§t√§ topbar
  int areaH = h - top; // ei alapalkkia

  // V√§ri rajan mukaan
  uint16_t col = hasFixStrong() ? ((kmph > SPEED_RED_KMPH) ? TFT_RED : TFT_WHITE) : TFT_DARKGREY;

  // Nopeus kokonaislukuna
  int spd = (int)roundf(max(0.0f, kmph));

  static int lastSpd = -9999;
  static uint16_t lastCol = 0;
  if (spd == lastSpd && col == lastCol) return; // ei muutosta -> ei redraw
  lastSpd = spd; lastCol = col;

  char buf[16];
  snprintf(buf, sizeof(buf), "%d", spd);

  // Tavoite: mahdutetaan (numero + v√§li + "km/h") vasemmalle leveydelle
  int targetW = (int)(w * 0.95f);
  int centerY = top + areaH / 2;

  int bestMain = 1;
  int bestNumW = 0, bestSfxW = 0;
  for (int s = 10; s >= 1; --s) {
    tft.setTextSize(s);
    int numW = tft.textWidth(buf);
    int sfxS = max(1, s/2);  // pienempi "km/h"
    tft.setTextSize(sfxS);
    int sfxW = tft.textWidth("km/h");
    int total = numW + 8 + sfxW; // 8px v√§li
    if (total <= targetW) { bestMain = s; bestNumW = numW; bestSfxW = sfxW; break; }
  }

  // Tyhjenn√§ keskialue vain redrawin yhteydess√§
  tft.startWrite();
  tft.fillRect(0, top, w, areaH, TFT_BLACK);

  // Piirr√§ keskitettyn√§ vaakasuunnassa
  int totalW = bestNumW + 8 + bestSfxW;
  int startX = (w - totalW) / 2;

  // Numero
  tft.setTextDatum(ML_DATUM); // Middle-Left
  tft.setTextSize(bestMain);
  tft.setTextColor(col, TFT_BLACK);
  tft.drawString(buf, startX, centerY);

  // Suffix "km/h"
  tft.setTextSize(max(1, bestMain/2));
  tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
  tft.drawString("km/h", startX + bestNumW + 8, centerY);
  tft.endWrite();
}



// ===================== GPS apu =====================
static int satCount() {
  if (gps.satellites.isValid()) return (int)gps.satellites.value();
  return -1;
}

static int fixType() {
  // Heuristiikka: jos sijainti validi ja tuore -> v√§hint√§√§n 2D; jos my√∂s korkeus validi ja tuore -> 3D
  bool locOK = gps.location.isValid() && gps.location.age() < 2000;
  bool altOK = gps.altitude.isValid() && gps.altitude.age() < 2000;
  if (!locOK) return 0;         // No fix
  if (altOK) return 3;          // 3D
  return 2;                     // 2D
}

static bool hasFixStrong() {
  // Tiukempi ehto nopeuden n√§ytt√§miseen
  bool locOK = gps.location.isValid() && gps.location.age() < 2000;
  int sats = gps.satellites.isValid() ? (int)gps.satellites.value() : 0;
  float hd = hdopValue();
  bool hdOK = (!isnan(hd) ? (hd < 10.0f) : false);
  return locOK && sats >= 3 && hdOK;
}

static float hdopValue() {
  if (gps.hdop.isValid()) {
    // TinyGPS++: hdop.value() on sadasosissa
    return gps.hdop.value() / 100.0f;
  }
  return NAN;
}

// ===================== GPS baud -autodetect =====================
static void gpsBeginAt(uint32_t baud) {
  GPSSerial.end();
  GPSSerial.begin(baud, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
}

static bool bufferHasNmea(const char* buf, size_t len) {
  for (size_t i=0;i+6<len;i++) {
    if (buf[i]=='$' && (buf[i+1]=='G' || buf[i+1]=='N')) {
      for (size_t j=i+2; j<i+80 && j<len; j++) {
        if (buf[j]=='*') return true;
      }
    }
  }
  return false;
}
static bool bufferHasUbx(const char* buf, size_t len) {
  for (size_t i=0;i+1<len;i++) if ((uint8_t)buf[i]==0xB5 && (uint8_t)buf[i+1]==0x62) return true;
  return false;
}

static uint32_t autoDetectGpsBaud(uint32_t timeoutPerBaudMs=1200) {
  const uint32_t candidates[] = {9600, 38400, 57600, 115200};
  char buf[256];
  for (uint32_t b : candidates) {
    gpsBeginAt(b);
    memset(buf, 0, sizeof(buf));
    size_t pos = 0;
    uint32_t start = millis();
    while (millis() - start < timeoutPerBaudMs) {
      while (GPSSerial.available()) {
        char c = GPSSerial.read();
        if (pos < sizeof(buf)-1) buf[pos++] = c;
        gps.encode(c);
        lastGpsMs = millis();
      }
      delay(1);
    }
    bool nmea = bufferHasNmea(buf, pos);
    bool ubx  = bufferHasUbx(buf, pos);
    if (nmea || ubx) {
      GPS_BAUD_USED = b;
      GPS_DET_UBX = ubx && !nmea;
      Serial.print(F("[GPS] Baud havaittu: ")); Serial.print(b);
      if (nmea) Serial.println(F(" (NMEA)")); else Serial.println(F(" (UBX)"));
      return b;
    }
  }
  Serial.println(F("[GPS] Baud ei l√∂ytynyt, k√§ytet√§√§n oletusta 9600"));
  gpsBeginAt(GPS_BAUD);
  GPS_BAUD_USED = GPS_BAUD;
  GPS_DET_UBX = false;
  return 0;
}

// ===================== GPS: NMEA p√§√§lle / asetukset =====================
static void sendUBX(uint8_t cls, uint8_t id, const uint8_t* payload, uint16_t len) {
  uint8_t ckA=0, ckB=0;
  auto upd=[&](uint8_t b){ ckA = ckA + b; ckB = ckB + ckA; };
  GPSSerial.write(0xB5); GPSSerial.write(0x62);
  GPSSerial.write(cls); upd(cls);
  GPSSerial.write(id);  upd(id);
  GPSSerial.write(len & 0xFF); upd(len & 0xFF);
  GPSSerial.write(len >> 8);    upd(len >> 8);
  for (uint16_t i=0;i<len;i++){ GPSSerial.write(payload[i]); upd(payload[i]); }
  GPSSerial.write(ckA); GPSSerial.write(ckB);
}

static void ubloxEnableNMEA1Hz() {
  // CFG-MSG for NMEA on UART1 (rateUART1=1)
  const uint8_t en_GGA[] = {0xF0,0x00, 0,1,0,0,0,0};
  const uint8_t en_GSA[] = {0xF0,0x02, 0,1,0,0,0,0};
  const uint8_t en_GSV[] = {0xF0,0x03, 0,1,0,0,0,0};
  const uint8_t en_RMC[] = {0xF0,0x04, 0,1,0,0,0,0};
  const uint8_t en_VTG[] = {0xF0,0x05, 0,1,0,0,0,0};
  sendUBX(0x06,0x01,en_GGA,sizeof(en_GGA));
  sendUBX(0x06,0x01,en_GSA,sizeof(en_GSA));
  sendUBX(0x06,0x01,en_GSV,sizeof(en_GSV));
  sendUBX(0x06,0x01,en_RMC,sizeof(en_RMC));
  sendUBX(0x06,0x01,en_VTG,sizeof(en_VTG));
  // CFG-RATE 1 Hz
  uint8_t rate[6];
  rate[0]=0xE8; rate[1]=0x03; // measRate 1000 ms (0x03E8)
  rate[2]=0x01; rate[3]=0x00; // navRate 1
  rate[4]=0x01; rate[5]=0x00; // timeRef 1 = GPS time
  sendUBX(0x06,0x08,rate,sizeof(rate));
  Serial.println(F("[GPS] UBX NMEA GGA/GSA/GSV/RMC/VTG @1Hz asetettu"));
}

static void sendPMTK(const String &body) {
  // Build PMTK sentence: $<body>*<checksum>\r\n  (checksum is XOR over the body)
  uint8_t cs = 0;
  for (size_t i = 0; i < body.length(); ++i) {
    cs ^= static_cast<uint8_t>(body[i]);
  }
  char sum[3];
  snprintf(sum, sizeof(sum), "%02X", cs);
  GPSSerial.print("$");
  GPSSerial.print(body);
  GPSSerial.print("*");
  GPSSerial.print(sum);
  GPSSerial.print("\r\n");
}

static void mediatekEnableNMEA1Hz() {
  // Enable RMC,GGA,GSA,GSV,VTG once per fix; disable others
  sendPMTK("PMTK314,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0");
  // 1 Hz update
  sendPMTK("PMTK220,1000");
  Serial.println(F("[GPS] PMTK NMEA GGA/GSA/GSV/RMC/VTG @1Hz asetettu"));
}

static void enableNMEA_All() {
  if (GPS_DET_UBX) ubloxEnableNMEA1Hz();
  else            mediatekEnableNMEA1Hz();
}


static int safeHeading() {
  if (gps.course.isValid() && gps.location.isValid()) {
    return (int)round(gps.course.deg());
  }
  return -1;
}

static void maybeAddDistance() {
  // Called whenever TinyGPS++ reports a *new* location (we check isUpdated())
  // and the receiver is actually moving. This integrates distance into ODO/TRIP.
  if (!gps.location.isValid()) return;
  if (!gps.location.isUpdated()) return;

  double lat = gps.location.lat();
  double lng = gps.location.lng();

  // Ignore distance accumulation when GPS says speed is near zero.
  if (gps.speed.isValid()) {
    if (gps.speed.kmph() < SPEED_MIN_ADD_KMPH) {
      // Reset last position so tiny wander while stationary won't accumulate.
      haveLastPos = false;
      return;
    }
  }

  if (haveLastPos) {
    // Haversine via TinyGPS++ helper; returns meters.
    double d_m = TinyGPSPlus::distanceBetween(lastLat, lastLng, lat, lng);
    double d_km = d_m / 1000.0;
    // Reject spikes (bad fixes or jumps) beyond a single-tick cap.
    if (d_km >= 0.0 && d_km <= DIST_ADD_MAX_KM_PER_TICK) {
      total_km += (float)d_km;
      trip_km  += (float)d_km;
    }
  }
  // Update last point (start a new segment if we were stationary before).
  lastLat = lat;
  lastLng = lng;
  haveLastPos = true;
}

// ===================== Wi‚ÄëFi & Web =====================
static String urlEncode(const String &s) {
  String out; out.reserve(s.length()*3);
  const char *hex = "0123456789ABCDEF";
  for (size_t i=0; i<s.length(); ++i) {
    unsigned char c = (unsigned char)s[i];
    if ((c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9')||c=='-'||c=='_'||c=='.'||c=='~') out += (char)c;
    else { out += '%'; out += hex[(c>>4)&0xF]; out += hex[c&0xF]; }
  }
  return out;
}

static String htmlPage() {
  // Luo yksinkertainen status-sivu
  float vbat = readBatteryVoltage();
  int   pbat = (int)roundf(lipoPercentFromVoltage(vbat));
  bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
  float kmToOil = max(0.0f, OIL_INTERVAL_KM - (total_km - oil_base_km));
  int sats = satCount();
  int fix = fixType();
  float hd = hdopValue();

  String s;
  s += F("<!doctype html><html><head><meta charset=\"utf-8\"><meta name=viewport content=\"width=device-width,initial-scale=1\">\n");
  s += F("<title>MopoSpeedo</title><style>body{font-family:sans-serif;margin:20px} .k{font-size:22px} button{font-size:18px;padding:8px 14px;margin:6px}</style></head><body>");
  s += F("<h2>MopoSpeedo</h2>");
  s += F("<p style=\"font-size:14px;color:#777\">NMEA debug: "); s += (NMEA_BRIDGE?"<b>P√§√§ll√§</b>":"Pois"); s += F(" ‚Äî ");
  if (!NMEA_BRIDGE) s += F("<a href=\"/nmea_on\">Kytke p√§√§lle</a>"); else s += F("<a href=\"/nmea_off\">Kytke pois</a>");
  s += F(" &nbsp; | &nbsp; <a href=\"/scan_baud\">Skannaa GPS-baud</a>");
  s += F(" &nbsp; | &nbsp; <a href=\"/enable_nmea\">Ota NMEA GGA/GSA/GSV/RMC/VTG k√§ytt√∂√∂n</a>");
  s += F("</p>");
  s += F("<div class=k><b>Kokonaismatka (ODO): </b>"); s += String(total_km, 1); s += F(" km</div>");
  s += F("<div class=k><b>Trippimittari (TRIP): </b>"); s += String(trip_km, 1); s += F(" km</div>");
  s += F("<div class=k><b>Satelliitit:</b> "); s += (sats>=0? String(sats): String("--")); s += F(" kpl</div>");
  s += F("<div class=k><b>GPS-fix:</b> "); s += (fix==3?"3D":(fix==2?"2D":"--")); s += F("</div>");
  s += F("<div class=k><b>HDOP:</b> "); s += (!isnan(hd)? String(hd,1): String("--")); s += F("</div>");
  s += F("<div class=k><b>GPS baud:</b> "); s += String(GPS_BAUD_USED); if (GPS_DET_UBX) s += F(" (UBX)"); s += F("</div>");
  s += F("<div class=k><b>Akku: </b>"); s += String(vbat, 2); s += F(" V &nbsp;("); s += String(pbat); s += F("%)</div>");
  s += F("<hr>");
  if (oilDue) {
    s += F("<div class=k style=\"color:#c00\"><b>\u26FD √ñljynvaihtohuomio:</b> Suositus teht√§v√§ nyt!</div>");
  } else {
    s += F("<div class=k><b>√ñljynvaihtoon:</b> "); s += String(kmToOil, 0); s += F(" km</div>");
  }
  s += F("<p><form action='/reset_trip' method='post'><button>‚ú≥ Nollaa TRIP</button></form></p>");
  s += F("<p><form action='/reset_oil' method='post'><button>üõ¢ Nollaa √∂ljynvaihto</button></form></p>");
  s += F("<p style=\"color:#666\">P√§√§sy: Wi‚ÄëFi AP \"MopoSpeedo\" (salasana \"mopo12345\"); Osoite: <a href='http://192.168.4.1/'>192.168.4.1</a></p>");
  s += F("<hr><h3>Huolto-ohje</h3>");
  s += F("<p><a href=\""); s += String(MAINT_URL); s += F("\" target=\"_blank\">Honda Monkey Z50J 1992‚Äì99 huolto-ohje (PDF)</a></p>");
  s += F("<hr><p style=\"color:#777;font-size:13px\">All code generated by ChatGPT 5</p></body></html>");
  return s;
}

static void handleRoot() { server.send(200, "text/html; charset=utf-8", htmlPage()); }
static void handleData() {
  float vbat = readBatteryVoltage();
  int pbat = (int)roundf(lipoPercentFromVoltage(vbat));
  bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
  int sats = satCount();
  int fix = fixType();
  float hd = hdopValue();
  String j = "{";
  j += "\"odo_km\":" + String(total_km, 3) + ",";
  j += "\"trip_km\":" + String(trip_km, 3) + ",";
  j += "\"vbat\":" + String(vbat, 3) + ",";
  j += "\"pbat\":" + String(pbat) + ",";
  j += "\"sats\":" + String(sats) + ",";
  j += "\"fix\":\"" + String(fix==3?"3D":(fix==2?"2D":"NONE")) + "\",";
  if (!isnan(hd)) j += "\"hdop\":" + String(hd, 2) + ","; else j += "\"hdop\":null,";
  j += "\"oil_due\":" + String(oilDue ? "true" : "false") + ",";
  j += "\"oil_next_km\":" + String(max(0.0f, OIL_INTERVAL_KM - (total_km - oil_base_km)), 1);
  j += "}";
  server.send(200, "application/json", j);
}


static void handleResetTrip() {
  trip_km = 0.0f;
  server.sendHeader("Location", "/");
  server.send(303);
}
static void handleResetOil() {
  oil_base_km = total_km;
  server.sendHeader("Location", "/");
  server.send(303);
}

static void setupWiFiAP() {
  WiFi.persistent(false);
  WiFi.mode(WIFI_AP);
  WiFi.setSleep(false);
  WiFi.softAP(AP_SSID, AP_PASS);
  delay(200);
  IPAddress ip = WiFi.softAPIP();
  Serial.print("AP IP: "); Serial.println(ip);

  server.on("/", HTTP_GET, handleRoot);
  server.on("/data.json", HTTP_GET, handleData);
  server.on("/reset_trip", HTTP_POST, handleResetTrip);
  server.on("/reset_oil",  HTTP_POST, handleResetOil);
  server.on("/manual", HTTP_GET, [](){ server.sendHeader("Location", MAINT_URL); server.send(302); });
  server.on("/nmea_on",  HTTP_GET, [](){ NMEA_BRIDGE = true;  server.sendHeader("Location","/"); server.send(303); });
  server.on("/nmea_off", HTTP_GET, [](){ NMEA_BRIDGE = false; server.sendHeader("Location","/"); server.send(303); });
  server.on("/scan_baud", HTTP_GET, [](){ autoDetectGpsBaud(1500); server.sendHeader("Location","/"); server.send(303); });
  server.on("/enable_nmea", HTTP_GET, [](){ enableNMEA_All(); server.sendHeader("Location","/"); server.send(303); });
  
  server.begin();
}

// ===================== Tallennus =====================
static void maybeSavePrefs() {
  uint32_t now = millis();
  if (now - lastSaveMs < 5000) return; // 5 s v√§li
  lastSaveMs = now;

  bool changed = false;
  if (fabs(total_km - lastSavedTotal) > 0.01f) { prefs.putFloat(KEY_ODO, total_km); lastSavedTotal = total_km; changed = true; }
  if (fabs(trip_km  - lastSavedTrip ) > 0.01f) { prefs.putFloat(KEY_TRIP, trip_km);   lastSavedTrip  = trip_km;  changed = true; }
  if (fabs(oil_base_km - lastSavedBase) > 0.01f) { prefs.putFloat(KEY_OILBASE, oil_base_km); lastSavedBase = oil_base_km; changed = true; }
  if (changed) Serial.println(F("[NVS] Talletettu ODO/TRIP/OILBASE"));
}

// ===================== setup/loop =====================
void setup() {
  Serial.begin(115200);
  delay(50);

  // --- Kriittiset T-Display S3 virrat: kun lauta on AKULLA, n√§ytt√∂ pysyy pime√§n√§ ellei 15 -> HIGH ---
  pinMode(TFT_POWER_PIN, OUTPUT);
  digitalWrite(TFT_POWER_PIN, HIGH);   // kytke n√§yt√∂n virta p√§√§lle (FAQ)
  pinMode(TFT_BL_PIN, OUTPUT);
  digitalWrite(TFT_BL_PIN, HIGH);      // taustavalo p√§√§lle
  delay(50);

  // TFT
  tft.init();
  tft.setRotation(3); // vaaka-asento
  tft.fillScreen(TFT_BLACK);
  tft.setTextSize(1);
  tft.setTextColor(TFT_WHITE, TFT_BLACK);
  tft.setTextDatum(MC_DATUM);

  // Splash-n√§ytt√∂ (Honda Monkey 1994)
  // Piirret√§√§n tyylitelty punainen "siipi" ja tekstit
  {
    int w = tft.width();
    int h = tft.height();
    int cx = w/2;
    int cy = h/2;

    // Siiven paikka vasemmalle puolelle
    int sx = cx - 70; // siiven vasen
    int sy = cy - 18; // siiven yl√§ankkuri

    // Piirr√§ 5 vinoa punaista "sulkakerrosta"
    tft.startWrite();
    for (int i=0;i<5;++i){
      int yy = sy + i*8;
      int barW = 64 - i*10; // kapenee alasp√§in
      int barH = 6;
      // Viistopalkki parallelogrammina kahdella kolmiolla
      // vasen alareuna -> oikea ylempi reuna (vinous)
      int x1 = sx;
      int y1 = yy;
      int x2 = sx + barW;
      int y2 = yy - 6; // kallistus yl√∂s oikealle
      int x3 = sx + barW;
      int y3 = yy + barH - 6;
      int x4 = sx;
      int y4 = yy + barH;
      tft.fillTriangle(x1,y1,x2,y2,x3,y3,TFT_RED);
      tft.fillTriangle(x1,y1,x4,y4,x3,y3,TFT_RED);
    }
    tft.endWrite();

    // Tekstit oikealle puolelle
    tft.setTextDatum(ML_DATUM);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextSize(3);
    tft.drawString("HONDA", cx - 10, cy - 6);
    tft.setTextSize(2);
    tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
    tft.drawString("Monkey 1994", cx - 10, cy + 14);

    // Credits rivi alareunaan
    tft.setTextDatum(MC_DATUM);
    tft.setTextSize(1);
    tft.setTextColor(TFT_DARKGREY, TFT_BLACK);
    tft.drawString("All code generated by ChatGPT 5", w/2, h - 10);
  }

  delay(SPLASH_MS);

  // ADC
  analogReadResolution(ADC_RES_BITS);
  analogSetPinAttenuation(BAT_ADC_PIN, ADC_11db);

  // GPS UART
  // Aloita oletuksella ja skannaa sitten
  GPSSerial.begin(GPS_BAUD, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  autoDetectGpsBaud(1500);

  // NVS
  prefs.begin(PREF_NAMESPACE, false);
  total_km    = prefs.getFloat(KEY_ODO, 0.0f);
  trip_km     = prefs.getFloat(KEY_TRIP, 0.0f);
  oil_base_km = prefs.getFloat(KEY_OILBASE, total_km);
  lastSavedTotal = total_km;
  lastSavedTrip  = trip_km;
  lastSavedBase  = oil_base_km;

  // Wi‚ÄëFi AP + web
  setupWiFiAP();

  delay(100);
  tft.fillScreen(TFT_BLACK);
}

void loop() {
  // GPS sy√∂tt√∂
  while (GPSSerial.available() > 0) {
    char c = GPSSerial.read();
    if (gps.encode(c)) lastGpsMs = millis();
  }

  // P√§ivit√§ matka kun sijainti p√§ivittyy
  maybeAddDistance();

  // UI refresh (throttled) ‚Äî keep the screen calm and battery-friendly.
  uint32_t now = millis();

  // 1) GPS-driven elements at ~1 Hz
  if (now - lastUiGpsMs >= UI_GPS_MS) {
    lastUiGpsMs = now;

    // RAW speed from GPS (km/h). TinyGPS++ updates at the NMEA rate (often 1 Hz).
    // We smooth it and gate on strong fix to avoid noisy or stale values.
    if (gps.speed.isValid() && (now - lastGpsMs) < 2000 && hasFixStrong()) {
      float k = gps.speed.kmph();
      filteredSpeed = SPEED_FILTER_ALPHA * k + (1.0f - SPEED_FILTER_ALPHA) * filteredSpeed;
    } else {
      // Decay toward zero when we lose a good fix to avoid frozen values.
      filteredSpeed = 0.95f * filteredSpeed;
      if (filteredSpeed < 0.05f) filteredSpeed = 0.0f;
    }

    // Draw main speed + right-side compass & fix diagnostics
    drawSpeed(filteredSpeed);
    int hdg = safeHeading();
    drawHeadingArrow((float)hdg);
    drawHeadingText(hdg);
    drawFixInfo(fixType(), hdopValue());
  }

  // 2) Top bar (battery/SAT/oil) ~1 Hz, redraw only if content changed
  if (now - lastUiTopMs >= UI_TOP_MS) {
    lastUiTopMs = now;
    float vbat = readBatteryVoltage();
    float pbat = lipoPercentFromVoltage(vbat);
    int sats = satCount();
    bool oilDue = ((total_km - oil_base_km) >= OIL_INTERVAL_KM);
    drawTopBar(vbat, pbat, sats, oilDue);
  }

  // Web server
  server.handleClient();

  // NMEA debug -silta: kaikki GPS->USB ja USB->GPS l√§pi
  if (NMEA_BRIDGE) {
    while (GPSSerial.available()) {
      char c = GPSSerial.read();
      Serial.write(c);       // n√§yt√§ Serial Monitorissa kaikki NMEA/UBX
      gps.encode(c);         // pid√§ parseri silti hengiss√§
      lastGpsMs = millis();
    }
    while (Serial.available()) {
      char c = Serial.read();
      GPSSerial.write(c);    // mahdollista l√§hett√§√§ komentoja GPS:lle (esim. u-blox)
    }
  }

  // Talletus
  maybeSavePrefs();
}
